/*.$file${.::defer.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: defer.qm
* File:  ${.::defer.c}
*
* This code has been generated by QM 5.1.4 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::defer.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "bsp.h"

#include "safe_std.h" /* portable "safe" <stdio.h>/<string.h> facilities */

Q_DEFINE_THIS_FILE

/*..........................................................................*/
enum TServerSignals {
    HELLO_WORLD_SIG = Q_USER_SIG,
    DEVICE_DETECT_SIG,
    DEVICE_DETECTED_SIG,
    DEVICE_READ_SIG,
    DEVICE_READ_COMPLETE_SIG,
    DEVICE_WRITE_SIG,
    DEVICE_WRITE_COMPLETE_SIG,
    TERMINATE_SIG,                /* terminate the application */
};
/*..........................................................................*/
/*.$declare${Events::SampleEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::SampleEvt} ....................................................*/
typedef struct {
/* protected: */
    QEvt super;

/* public: */
    uint8_t prop1;
} SampleEvt;
/*.$enddecl${Events::SampleEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
    // this was just used to size an event pool/*.$declare${Events::DeviceDetectEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::DeviceDetectEvt} ..............................................*/
typedef struct {
/* protected: */
    QEvt super;
} DeviceDetectEvt;
/*.$enddecl${Events::DeviceDetectEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${Events::DeviceDetectedEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::DeviceDetectedEvt} ............................................*/
typedef struct {
/* protected: */
    QEvt super;
} DeviceDetectedEvt;
/*.$enddecl${Events::DeviceDetectedEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${Events::DeviceReadEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::DeviceReadEvt} ................................................*/
typedef struct {
/* protected: */
    QEvt super;
} DeviceReadEvt;
/*.$enddecl${Events::DeviceReadEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${Events::DeviceReadCompleteEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::DeviceReadCompleteEvt} ........................................*/
typedef struct {
/* protected: */
    QEvt super;
} DeviceReadCompleteEvt;
/*.$enddecl${Events::DeviceReadCompleteEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${Events::DeviceWriteEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::DeviceWriteEvt} ...............................................*/
typedef struct {
/* protected: */
    QEvt super;
} DeviceWriteEvt;
/*.$enddecl${Events::DeviceWriteEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$declare${Events::DeviceWriteCompleteEvt} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${Events::DeviceWriteCompleteEvt} .......................................*/
typedef struct {
/* protected: */
    QEvt super;
} DeviceWriteCompleteEvt;
/*.$enddecl${Events::DeviceWriteCompleteEvt} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Active object class -----------------------------------------------------*/
/*.$declare${Components::Comms} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/* Communications AO */
/*.${Components::Comms} ....................................................*/
typedef struct Comms {
/* protected: */
    QActive super;

/* private: */
    QEQueue messageQueue;

/* public: */

/* private: */
    QEvt const* messageQueueSto[5];
} Comms;

/* public: */
static void Comms_ctor(Comms * const me);
extern Comms Comms_inst;

/* protected: */
static QState Comms_initial(Comms * const me, void const * const par);
static QState Comms_idle(Comms * const me, QEvt const * const e);
static QState Comms_busy(Comms * const me, QEvt const * const e);
static QState Comms_detecting(Comms * const me, QEvt const * const e);
static QState Comms_reading(Comms * const me, QEvt const * const e);
static QState Comms_writing(Comms * const me, QEvt const * const e);
/*.$enddecl${Components::Comms} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${Components::Comms} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/* Communications AO */
/*.${Components::Comms} ....................................................*/
Comms Comms_inst;
/*.${Components::Comms::ctor} ..............................................*/
static void Comms_ctor(Comms * const me) {
    QActive_ctor(&me->super, Q_STATE_CAST(&Comms_initial));
    QEQueue_init(&me->messageQueue,
                      me->messageQueueSto, Q_DIM(me->messageQueueSto));
}

/*.${Components::Comms::SM} ................................................*/
static QState Comms_initial(Comms * const me, void const * const par) {
    /*.${Components::Comms::SM::initial} */
    return Q_TRAN(&Comms_idle);
}
/*.${Components::Comms::SM::idle} ..........................................*/
static QState Comms_idle(Comms * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${Components::Comms::SM::idle} */
        case Q_ENTRY_SIG: {
            printf("comms-idle-ENTRY;\n");

            /* recall the oldest deferred request... */
            if (QActive_recall(&me->super, &me->messageQueue))
            {
                printf("%s\n", "Request recalled");
            }
            else
            {
                printf("%s\n", "No deferred requests");
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::idle} */
        case Q_EXIT_SIG: {
            printf("comms-idle-EXIT;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::idle::DEVICE_DETECT} */
        case DEVICE_DETECT_SIG: {
            status_ = Q_TRAN(&Comms_detecting);
            break;
        }
        /*.${Components::Comms::SM::idle::DEVICE_READ} */
        case DEVICE_READ_SIG: {
            status_ = Q_TRAN(&Comms_reading);
            break;
        }
        /*.${Components::Comms::SM::idle::DEVICE_WRITE} */
        case DEVICE_WRITE_SIG: {
            status_ = Q_TRAN(&Comms_writing);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${Components::Comms::SM::busy} ..........................................*/
static QState Comms_busy(Comms * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${Components::Comms::SM::busy} */
        case Q_ENTRY_SIG: {
            printf("comms-busy-ENTRY;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy} */
        case Q_EXIT_SIG: {
            printf("comms-busy-EXIT;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::DEVICE_DETECT} */
        case DEVICE_DETECT_SIG: {
            /* defer the new device detect event... */
            QActive_defer(&me->super, &me->messageQueue, e);
            printf("Device detect deferred;\n");


            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::DEVICE_READ} */
        case DEVICE_READ_SIG: {
            /* defer the new device read event... */
            QActive_defer(&me->super, &me->messageQueue, e);
            printf("Device read deferred;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::DEVICE_WRITE} */
        case DEVICE_WRITE_SIG: {
            /* defer the new device write event... */
            QActive_defer(&me->super, &me->messageQueue, e);
            printf("Device write deferred;\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${Components::Comms::SM::busy::detecting} ...............................*/
static QState Comms_detecting(Comms * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${Components::Comms::SM::busy::detecting} */
        case Q_ENTRY_SIG: {
            printf("comms-detecting-ENTRY;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::detecting} */
        case Q_EXIT_SIG: {
            printf("comms-detecting-EXIT;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::detecting::DEVICE_DETECTED} */
        case DEVICE_DETECTED_SIG: {
            status_ = Q_TRAN(&Comms_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&Comms_busy);
            break;
        }
    }
    return status_;
}
/*.${Components::Comms::SM::busy::reading} .................................*/
static QState Comms_reading(Comms * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${Components::Comms::SM::busy::reading} */
        case Q_ENTRY_SIG: {
            printf("comms-read-ENTRY;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::reading} */
        case Q_EXIT_SIG: {
            printf("comms-read-EXIT;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::reading::DEVICE_READ_COMPLETE} */
        case DEVICE_READ_COMPLETE_SIG: {
            status_ = Q_TRAN(&Comms_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&Comms_busy);
            break;
        }
    }
    return status_;
}
/*.${Components::Comms::SM::busy::writing} .................................*/
static QState Comms_writing(Comms * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${Components::Comms::SM::busy::writing} */
        case Q_ENTRY_SIG: {
            printf("comms-write-ENTRY;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::writing} */
        case Q_EXIT_SIG: {
            printf("comms-write-EXIT;\n");
            status_ = Q_HANDLED();
            break;
        }
        /*.${Components::Comms::SM::busy::writing::DEVICE_WRITE_COMPLETE} */
        case DEVICE_WRITE_COMPLETE_SIG: {
            status_ = Q_TRAN(&Comms_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&Comms_busy);
            break;
        }
    }
    return status_;
}
/*.$enddef${Components::Comms} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


// test harness ============================================================*/

// Local-scope objects -------------------------------------------------------
static QEvt const *l_tserverQSto[10]; /* Event queue storage for TServer */
static QEvt const *l_commsQSto[10]; /* Event queue storage for Comms */
static QF_MPOOL_EL(SampleEvt) l_smlPoolSto[50]; /* storage for small pool */

/*..........................................................................*/
int main(int argc, char *argv[]) {
    PRINTF_S("Deferred Event state pattern\nQP version: %s\n"
            "Press 'd' to generate a new device detect request\n"
            "Press 'D' to generate a new device detect complete event\n"
            "Press 'r' to generate a new device read request\n"
            "Press 'R' to generate a new device read complete event\n"
            "Press 'w' to generate a new device write request\n"
            "Press 'W' to generate a new device write complete event\n\n\n",
           QP_VERSION_STR);

    QF_init(); /* initialize the framework and the underlying RTOS/OS */

    BSP_init(argc, argv); /* initialize the BSP */

    /* publish-subscribe not used, no call to QF_psInit() */

    /* initialize event pools... */
    QF_poolInit(l_smlPoolSto, sizeof(l_smlPoolSto), sizeof(l_smlPoolSto[0]));

    QS_SIG_DICTIONARY(TERMINATE_SIG,   (void *)0);

    /* start the active objects... */
    Comms_ctor(&Comms_inst);
    QACTIVE_START((QActive *)&Comms_inst,
                  2U,
                  l_commsQSto, Q_DIM(l_commsQSto),
                  (void *)0, 0U, (void *)0);

    return QF_run(); /* run the QF application */
}
/*..........................................................................*/
void BSP_onKeyboardInput(uint8_t key)
{
    switch (key)
    {
        case '\33':
        { /* ESC pressed? */
            static QEvt const terminateEvt = { TERMINATE_SIG, 0U, 0U };
            QACTIVE_POST((QActive *)&Comms_inst, &terminateEvt, (void *)0);
            break;
        }
        case 'd':
        {    /* 'd': device detect request */
            DeviceDetectEvt *e = Q_NEW(DeviceDetectEvt, DEVICE_DETECT_SIG);
            /* post directly to comms active object */
            QACTIVE_POST((QActive *)&Comms_inst, (QEvt *)e, (void *)0);
            break;
        }
        case 'D':
        {    /* 'D': device detected */
            DeviceDetectedEvt *e = Q_NEW(DeviceDetectedEvt, DEVICE_DETECTED_SIG);
            /* post directly to comms active object */
            QACTIVE_POST((QActive *)&Comms_inst, (QEvt *)e, (void *)0);
            break;
        }
        case 'r':
        {    /* 'r': device read request */
            DeviceReadEvt *e = Q_NEW(DeviceReadEvt, DEVICE_READ_SIG);
            /* post directly to comms active object */
            QACTIVE_POST((QActive *)&Comms_inst, (QEvt *)e, (void *)0);
            break;
        }
        case 'R':
        {    /* 'R': device read completed */
            DeviceReadCompleteEvt *e = Q_NEW(DeviceReadCompleteEvt, DEVICE_READ_COMPLETE_SIG);
            /* post directly to comms active object */
            QACTIVE_POST((QActive *)&Comms_inst, (QEvt *)e, (void *)0);
            break;
        }
        case 'w':
        {    /* 'w': device write request */
            DeviceWriteEvt *e = Q_NEW(DeviceWriteEvt, DEVICE_WRITE_SIG);
            /* post directly to comms active object */
            QACTIVE_POST((QActive *)&Comms_inst, (QEvt *)e, (void *)0);
            break;
        }
        case 'W':
        {    /* 'W': device write completed */
            DeviceWriteCompleteEvt *e = Q_NEW(DeviceWriteCompleteEvt, DEVICE_WRITE_COMPLETE_SIG);
            /* post directly to comms active object */
            QACTIVE_POST((QActive *)&Comms_inst, (QEvt *)e, (void *)0);
            break;
        }
    }
}
